
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>examples: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ambientlabscomputing/go_event_client/examples/comprehensive_demo.go (0.0%)</option>
				
				<option value="file1">github.com/ambientlabscomputing/go_event_client/go_event_client.go (56.5%)</option>
				
				<option value="file2">github.com/ambientlabscomputing/go_event_client/samples/sample.go (0.0%)</option>
				
				<option value="file3">github.com/ambientlabscomputing/go_event_client/test_helpers.go (76.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "log/slog"
        "os"
        "time"

        "github.com/ambientlabscomputing/go_event_client"
)

func main() <span class="cov0" title="0">{
        // Set up logging
        logger := slog.New(slog.NewTextHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: slog.LevelInfo,
        }))

        // Load environment variables
        apiURL := os.Getenv("AMBIENT_EVENT_API_URL")
        socketsURL := os.Getenv("AMBIENT_SOCKETS_URL")
        clientID := os.Getenv("AMBIENT_CLIENT_ID")
        clientSecret := os.Getenv("AMBIENT_CLIENT_SECRET")
        oauthURL := os.Getenv("AMBIENT_OAUTH_URL")

        if apiURL == "" || socketsURL == "" || clientID == "" || clientSecret == "" || oauthURL == "" </span><span class="cov0" title="0">{
                log.Fatal("Missing required environment variables. Please set AMBIENT_EVENT_API_URL, AMBIENT_SOCKETS_URL, AMBIENT_CLIENT_ID, AMBIENT_CLIENT_SECRET, and AMBIENT_OAUTH_URL")
        }</span>

        // Create OAuth token callback
        <span class="cov0" title="0">getTokenCallback := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                return go_event_client.GetOAuthToken(ctx, oauthURL, clientID, clientSecret)
        }</span>

        // Create client options
        <span class="cov0" title="0">options := go_event_client.EventClientOptions{
                EventAPIURL:  apiURL,
                SocketsURL:   socketsURL,
                PingInterval: 30,
        }

        // Create the event client
        ctx := context.Background()
        client := go_event_client.NewEventClient(ctx, options, getTokenCallback, logger)

        // Start the client
        if err := client.Start(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start client: %v", err)
        }</span>
        <span class="cov0" title="0">defer client.Stop()

        logger.Info("Event client started successfully")

        // Example 1: Basic subscription and message handling
        fmt.Println("\n=== Example 1: Basic Subscription ===")

        err := client.AddHandler("^demo\\.basic\\..*", func(message string) </span><span class="cov0" title="0">{
                fmt.Printf("📨 Basic message received: %s\n", message)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to add basic handler: %v", err)
        }</span>

        <span class="cov0" title="0">err = client.NewSubscription(ctx, "demo.basic.test")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create basic subscription: %v", err)
        }</span>

        // Wait for subscription to be established
        <span class="cov0" title="0">time.Sleep(2 * time.Second)

        // Publish a basic message
        basicMessage := map[string]interface{}{
                "type":      "notification",
                "message":   "Hello from basic demo!",
                "timestamp": time.Now().Format(time.RFC3339),
        }

        err = client.Publish("demo.basic.test", basicMessage)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to publish basic message: %v", err)
        }</span>

        // Example 2: Aggregate type subscription
        <span class="cov0" title="0">fmt.Println("\n=== Example 2: Aggregate Type Subscription ===")

        err = client.AddHandler("^demo\\.user\\..*", func(message string) </span><span class="cov0" title="0">{
                fmt.Printf("👤 User aggregate message received: %s\n", message)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to add user handler: %v", err)
        }</span>

        // Subscribe to all user events
        <span class="cov0" title="0">err = client.NewAggregateTypeSubscription(ctx, "demo.user.updated", "user", false)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create user aggregate subscription: %v", err)
        }</span>

        <span class="cov0" title="0">time.Sleep(2 * time.Second)

        // Publish a message with aggregate information
        userMessage := map[string]interface{}{
                "action":    "profile_updated",
                "user_id":   123,
                "username":  "john_doe",
                "timestamp": time.Now().Format(time.RFC3339),
        }

        err = client.PublishWithAggregate("demo.user.updated", userMessage, "user", nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to publish user message: %v", err)
        }</span>

        // Example 3: Specific aggregate subscription
        <span class="cov0" title="0">fmt.Println("\n=== Example 3: Specific Aggregate Subscription ===")

        err = client.AddHandler("^demo\\.order\\..*", func(message string) </span><span class="cov0" title="0">{
                fmt.Printf("🛒 Order aggregate message received: %s\n", message)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to add order handler: %v", err)
        }</span>

        // Subscribe to a specific order
        <span class="cov0" title="0">specificOrderID := 456
        err = client.NewAggregateSubscription(ctx, "demo.order.status", "order", specificOrderID, false)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create specific order subscription: %v", err)
        }</span>

        <span class="cov0" title="0">time.Sleep(2 * time.Second)

        // Publish a message for the specific order
        orderMessage := map[string]interface{}{
                "action":    "status_changed",
                "order_id":  456,
                "status":    "shipped",
                "tracking":  "1Z999AA1234567890",
                "timestamp": time.Now().Format(time.RFC3339),
        }

        err = client.PublishWithAggregate("demo.order.status", orderMessage, "order", &amp;specificOrderID)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to publish order message: %v", err)
        }</span>

        // Example 4: Regex subscription
        <span class="cov0" title="0">fmt.Println("\n=== Example 4: Regex Subscription ===")

        err = client.AddHandler("^demo\\.system\\..*", func(message string) </span><span class="cov0" title="0">{
                fmt.Printf("🔧 System message received: %s\n", message)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to add system handler: %v", err)
        }</span>

        // Create a regex subscription that matches multiple topics
        <span class="cov0" title="0">err = client.NewSubscriptionWithOptions(ctx, "demo\\.system\\..*", "", nil, true)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create regex subscription: %v", err)
        }</span>

        <span class="cov0" title="0">time.Sleep(2 * time.Second)

        // Publish multiple messages that should match the regex
        systemTopics := []string{
                "demo.system.health",
                "demo.system.metrics",
                "demo.system.alerts",
        }

        for i, topic := range systemTopics </span><span class="cov0" title="0">{
                systemMessage := map[string]interface{}{
                        "type":      "system_event",
                        "topic":     topic,
                        "sequence":  i + 1,
                        "data":      fmt.Sprintf("System event #%d", i+1),
                        "timestamp": time.Now().Format(time.RFC3339),
                }

                err = client.Publish(topic, systemMessage)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to publish system message to %s: %v", topic, err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("📤 Published message to %s\n", topic)
                }</span>

                // Small delay between messages
                <span class="cov0" title="0">time.Sleep(500 * time.Millisecond)</span>
        }

        // Example 5: HTTP API Publishing (if connection_id is available)
        <span class="cov0" title="0">fmt.Println("\n=== Example 5: HTTP API Publishing ===")

        // Wait a bit to ensure we have a connection_id from received messages
        time.Sleep(3 * time.Second)

        apiMessage := map[string]interface{}{
                "type":      "api_published",
                "message":   "This message was published via HTTP API",
                "method":    "HTTP",
                "timestamp": time.Now().Format(time.RFC3339),
        }

        err = client.PublishViaAPI(ctx, "demo.basic.test", apiMessage, "", nil)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("⚠️  Failed to publish via API (this is expected if no messages were received yet): %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("📤 Successfully published message via HTTP API")
        }</span>

        // Wait to see all messages
        <span class="cov0" title="0">fmt.Println("\n=== Waiting for messages (5 seconds) ===")
        time.Sleep(5 * time.Second)

        fmt.Println("\n=== Demo completed successfully! ===")
        fmt.Println("All event bus features have been demonstrated:")
        fmt.Println("✅ Basic subscriptions and publishing")
        fmt.Println("✅ Aggregate type subscriptions")
        fmt.Println("✅ Specific aggregate subscriptions")
        fmt.Println("✅ Regex pattern subscriptions")
        fmt.Println("✅ HTTP API publishing")
        fmt.Println("✅ Real-time message handling")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package go_event_client

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "log/slog"
        "net/http"
        "regexp"
        "sync"
        "time"

        "github.com/gorilla/websocket"
)

type GetTokenCallback func(ctx context.Context) (string, error)

type EventClient interface {
        Start() error
        Stop() error
        AddHandler(expr string, handler func(string)) error
        Publish(topic string, v interface{}) error
        PublishWithAggregate(topic string, v interface{}, aggregateType string, aggregateID *int) error
        PublishViaAPI(ctx context.Context, topic string, v interface{}, aggregateType string, aggregateID *int) error
        NewSubscription(ctx context.Context, topic string) error
        NewSubscriptionWithOptions(ctx context.Context, topic string, aggregateType string, aggregateID *int, isRegex bool) error
        NewAggregateTypeSubscription(ctx context.Context, topic string, aggregateType string, isRegex bool) error
        NewAggregateSubscription(ctx context.Context, topic string, aggregateType string, aggregateID int, isRegex bool) error
}

type EventClientOptions struct {
        EventAPIURL  string
        SocketsURL   string
        PingInterval int
}

type handlerEntry struct {
        pattern *regexp.Regexp
        handler func(string)
}

type EventClientImpl struct {
        Ctx              context.Context
        Options          EventClientOptions
        GetTokenCallback GetTokenCallback
        Logger           *slog.Logger
        HTTPClient       *http.Client

        // internal values set during runtime
        Subscriber   *Subscriber
        Session      *Session
        ConnectionID string
        conn         *websocket.Conn
        send         chan []byte
        handlers     []handlerEntry
        mu           sync.RWMutex
        ctx          context.Context
        cancel       context.CancelFunc
}

func NewEventClient(ctx context.Context, options EventClientOptions, getTokenCallback GetTokenCallback, logger *slog.Logger) EventClient <span class="cov2" title="4">{
        return &amp;EventClientImpl{
                Ctx:              ctx,
                Options:          options,
                GetTokenCallback: getTokenCallback,
                Logger:           logger,
                HTTPClient:       &amp;http.Client{},
        }
}</span>

func (e *EventClientImpl) Start() error <span class="cov2" title="4">{
        logger := e.Logger

        logger.Debug("starting event client", "event_api_url", e.Options.EventAPIURL, "sockets_url", e.Options.SocketsURL)
        if err := e.RegisterSubscriber(); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to register subscriber", "error", err)
                return err
        }</span>
        <span class="cov2" title="4">logger.Info("subscriber registered", "subscriber_id", e.Subscriber.ID)

        if err := e.RequestSession(); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to request session", "error", err)
                return err
        }</span>
        <span class="cov2" title="4">logger.Info("session requested", "session_id", e.Session.ID)

        e.ctx, e.cancel = context.WithCancel(e.Ctx)
        e.send = make(chan []byte, 256)

        var err error
        connURI := e.Options.SocketsURL + "/ws/" + e.Session.Token
        logger.Info("connecting to websocket", "url", connURI)
        e.conn, _, err = websocket.DefaultDialer.Dial(connURI, nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to connect to websocket", "error", err)
                return err
        }</span>

        <span class="cov2" title="4">go e.writePump()
        go e.readPump()
        logger.Info("connected to websocket", "url", e.Options.SocketsURL)

        return nil</span>
}

func (e *EventClientImpl) RegisterSubscriber() error <span class="cov2" title="4">{
        token, err := e.GetTokenCallback(e.Ctx)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger.Error("failed to get token", "error", err)
                return err
        }</span>
        <span class="cov2" title="4">req, err := http.NewRequestWithContext(e.Ctx, http.MethodPost, e.Options.EventAPIURL+"/v2/subscribers", nil)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger.Error("failed to create request", "error", err)
                return err
        }</span>
        <span class="cov2" title="4">req.Header.Set("Authorization", "Bearer "+token)
        req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Accept", "application/json")

        resp, err := e.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                errData, _ := io.ReadAll(resp.Body)
                e.Logger.Error("failed to send request", "error", err, "data", errData)
                return err
        }</span>

        <span class="cov2" title="4">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                errData, _ := io.ReadAll(resp.Body)
                e.Logger.Error("failed to register subscriber", "status_code", resp.StatusCode, "data", string(errData))
                return fmt.Errorf("failed to register subscriber: status %d, body: %s", resp.StatusCode, string(errData))
        }</span>

        <span class="cov2" title="4">var subscriber Subscriber
        defer resp.Body.Close()
        if err := json.NewDecoder(resp.Body).Decode(&amp;subscriber); err != nil </span><span class="cov0" title="0">{
                e.Logger.Error("failed to decode response", "error", err)
                return err
        }</span>
        <span class="cov2" title="4">e.Subscriber = &amp;subscriber
        e.Logger.Info("subscriber registered", "subscriber_id", subscriber.ID)
        return nil</span>
}

func (e *EventClientImpl) RequestSession() error <span class="cov2" title="4">{
        logger := e.Logger
        if e.Subscriber == nil </span><span class="cov0" title="0">{
                logger.Error("subscriber not registered")
                return fmt.Errorf("subscriber not registered")
        }</span>
        <span class="cov2" title="4">token, err := e.GetTokenCallback(e.Ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get token", "error", err)
                return err
        }</span>
        <span class="cov2" title="4">req, err := http.NewRequestWithContext(e.Ctx, http.MethodPost, e.Options.EventAPIURL+"/v2/sessions", nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create request", "error", err)
                return err
        }</span>
        <span class="cov2" title="4">req.Header.Set("Authorization", "Bearer "+token)
        req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Accept", "application/json")

        resp, err := e.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                errData, _ := io.ReadAll(resp.Body)
                logger.Error("failed to send request", "error", err, "data", errData)
                return err
        }</span>

        <span class="cov2" title="4">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                errData, _ := io.ReadAll(resp.Body)
                logger.Error("failed to request session", "status_code", resp.StatusCode, "data", string(errData))
                return fmt.Errorf("failed to request session: status %d, body: %s", resp.StatusCode, string(errData))
        }</span>

        <span class="cov2" title="4">var session Session
        defer resp.Body.Close()
        if err := json.NewDecoder(resp.Body).Decode(&amp;session); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to decode response", "error", err)
                return err
        }</span>
        <span class="cov2" title="4">e.Session = &amp;session
        logger.Info("session requested", "session_id", session.ID)
        return nil</span>
}

// readPump blocks on ReadMessage, parsing incoming JSON frames and dispatching
func (e *EventClientImpl) readPump() <span class="cov2" title="4">{
        defer e.cancel()
        logger := e.Logger

        // Set limits and pong handler
        logger.Debug("setting read limits and pong handler")
        e.conn.SetReadLimit(65536) // 64KB limit
        e.conn.SetReadDeadline(time.Now().Add(time.Duration(e.Options.PingInterval) * time.Second))
        e.conn.SetPongHandler(func(appData string) error </span><span class="cov9" title="181622">{
                e.conn.SetReadDeadline(time.Now().Add(time.Duration(e.Options.PingInterval) * time.Second))
                return nil
        }</span>)
        <span class="cov2" title="4">logger.Debug("starting read pump")

        for </span><span class="cov2" title="9">{
                select </span>{
                case &lt;-e.ctx.Done():<span class="cov0" title="0">
                        logger.Debug("context done, stopping read pump")
                        return</span>
                default:<span class="cov2" title="9">
                        _, data, err := e.conn.ReadMessage()
                        if err != nil </span><span class="cov2" title="4">{
                                // Check if this is a graceful shutdown
                                if websocket.IsCloseError(err, websocket.CloseNormalClosure, websocket.CloseGoingAway) </span><span class="cov0" title="0">{
                                        logger.Debug("websocket closed gracefully", "error", err)
                                        return
                                }</span> else<span class="cov2" title="4"> {
                                        logger.Error("failed to read message", "error", err)
                                        return
                                }</span>
                        }
                        // Dispatch matching handlers in their own goroutines
                        <span class="cov2" title="5">go e.dispatch(data)</span>
                }
        }
}

// writePump blocks on the send channel and ticker for pings
func (e *EventClientImpl) writePump() <span class="cov2" title="4">{
        ticker := time.NewTicker(time.Duration(e.Options.PingInterval))
        defer func() </span><span class="cov2" title="4">{
                ticker.Stop()
                e.conn.Close()
                e.cancel()
        }</span>()

        <span class="cov2" title="4">for </span><span class="cov10" title="241134">{
                select </span>{
                case msg := &lt;-e.send:<span class="cov2" title="5">
                        e.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
                        if err := e.conn.WriteMessage(websocket.TextMessage, msg); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                case &lt;-ticker.C:<span class="cov9" title="241129">
                        e.conn.SetWriteDeadline(time.Now().Add(10 * time.Second))
                        if err := e.conn.WriteMessage(websocket.PingMessage, nil); err != nil </span><span class="cov2" title="4">{
                                return
                        }</span>

                case &lt;-e.ctx.Done():<span class="cov0" title="0">
                        return</span>
                }
        }
}

// dispatch unmarshals the frame and calls all handlers whose regex matches the topic
func (e *EventClientImpl) dispatch(raw []byte) <span class="cov2" title="5">{
        logger := e.Logger

        logger.Debug("dispatching message", "raw_data", string(raw))
        if len(raw) == 0 </span><span class="cov0" title="0">{
                logger.Warn("received empty frame, ignoring")
                return
        }</span>

        <span class="cov2" title="5">var m Message
        if err := json.Unmarshal(raw, &amp;m); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to unmarshal message", "error", err, "raw_data", string(raw))
                return
        }</span>

        // Capture connection ID from the first message for API publishing
        <span class="cov2" title="5">if e.ConnectionID == "" &amp;&amp; m.ConnectionID != "" </span><span class="cov2" title="4">{
                e.ConnectionID = m.ConnectionID
                logger.Debug("captured connection ID", "connection_id", e.ConnectionID)
        }</span>

        <span class="cov2" title="5">e.mu.RLock()
        logger.Debug("acquired read lock for handlers", "num_handlers", len(e.handlers))
        if len(e.handlers) == 0 </span><span class="cov0" title="0">{
                logger.Debug("no handlers registered, ignoring message", "topic", m.Topic)
                e.mu.RUnlock()
                return
        }</span>
        // Copy handlers to avoid holding the lock while calling them
        <span class="cov2" title="5">logger.Debug("found handlers for topic", "topic", m.Topic, "num_handlers", len(e.handlers))
        entries := append([]handlerEntry(nil), e.handlers...)
        e.mu.RUnlock()

        found_handler := false
        for _, entry := range entries </span><span class="cov2" title="5">{
                logger.Debug("checking handler", "pattern", entry.pattern.String(), "topic", m.Topic)
                if entry.pattern.MatchString(m.Topic) </span><span class="cov2" title="5">{
                        logger.Debug("handler matched", "pattern", entry.pattern.String(), "topic", m.Topic)
                        found_handler = true
                        go entry.handler(m.Message)
                }</span>
                <span class="cov2" title="5">if !found_handler </span><span class="cov0" title="0">{
                        logger.Warn("no handler matched for topic", "topic", m.Topic, "pattern", entry.pattern.String())
                }</span>
        }
}

// AddHandler registers a callback for topics matching the given regex
// The expr should be a valid Go regex (e.g. "^user\\..*$" to match "user.*").
func (e *EventClientImpl) AddHandler(expr string, handler func(string)) error <span class="cov2" title="4">{
        re, err := regexp.Compile(expr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov2" title="4">e.mu.Lock()
        e.handlers = append(e.handlers, handlerEntry{pattern: re, handler: handler})
        e.mu.Unlock()
        return nil</span>
}

// Publish sends a topic and payload. It blocks only if the send buffer is full.
func (e *EventClientImpl) Publish(topic string, v interface{}) error <span class="cov1" title="3">{
        return e.PublishWithAggregate(topic, v, "", nil)
}</span>

// PublishWithAggregate sends a topic and payload with aggregate information
func (e *EventClientImpl) PublishWithAggregate(topic string, v interface{}, aggregateType string, aggregateID *int) error <span class="cov2" title="5">{
        msg := Message{
                Topic:         topic,
                AggregateType: aggregateType,
                AggregateID:   aggregateID,
        }
        data, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov2" title="5">msg.Message = string(data)

        frame, err := json.Marshal(msg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov2" title="5">select </span>{
        case e.send &lt;- frame:<span class="cov2" title="5">
                return nil</span>
        case &lt;-e.ctx.Done():<span class="cov0" title="0">
                return e.ctx.Err()</span>
        }
}

// PublishViaAPI publishes a message via HTTP API instead of WebSocket (useful for testing)
func (e *EventClientImpl) PublishViaAPI(ctx context.Context, topic string, v interface{}, aggregateType string, aggregateID *int) error <span class="cov0" title="0">{
        if e.Session == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("session not available for API publishing")
        }</span>
        <span class="cov0" title="0">if e.ConnectionID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("connection ID not available for API publishing - ensure WebSocket connection is established and at least one message has been received")
        }</span>

        <span class="cov0" title="0">token, err := e.GetTokenCallback(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">data, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">msgCreate := MessageCreate{
                Topic:         topic,
                Message:       string(data),
                AggregateType: aggregateType,
                AggregateID:   aggregateID,
        }

        jsonData, err := json.Marshal(msgCreate)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Add required query parameters
        <span class="cov0" title="0">url := fmt.Sprintf("%s/v2/messages?session_id=%s&amp;connection_id=%s", e.Options.EventAPIURL, e.Session.ID, e.ConnectionID)

        req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+token)
        req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Accept", "application/json")

        resp, err := e.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                errData, _ := io.ReadAll(resp.Body)
                return fmt.Errorf("failed to publish message: status %d, body: %s", resp.StatusCode, string(errData))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (e *EventClientImpl) Stop() error <span class="cov2" title="4">{
        e.cancel()
        if e.conn != nil </span><span class="cov2" title="4">{
                e.conn.Close()
        }</span>
        <span class="cov2" title="4">return nil</span>
}

func (e *EventClientImpl) NewSubscription(ctx context.Context, topic string) error <span class="cov1" title="1">{
        return e.NewSubscriptionWithOptions(ctx, topic, "", nil, false)
}</span>

func (e *EventClientImpl) NewSubscriptionWithOptions(ctx context.Context, topic string, aggregateType string, aggregateID *int, isRegex bool) error <span class="cov2" title="4">{
        // call the API to create a new subscription
        e.Logger.Info("creating new subscription", "topic", topic, "aggregate_type", aggregateType, "aggregate_id", aggregateID, "is_regex", isRegex)
        token, err := e.GetTokenCallback(ctx)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger.Error("failed to get token", "error", err)
                return err
        }</span>
        <span class="cov2" title="4">e.Logger.Debug("got token for subscription")

        subscription := SubscriptionCreate{
                Topic:         topic,
                SubscriberID:  e.Subscriber.ID,
                AggregateType: aggregateType,
                AggregateID:   aggregateID,
                IsRegex:       isRegex,
        }

        jsonData, err := json.Marshal(subscription)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger.Error("failed to marshal subscription", "error", err)
                return err
        }</span>

        <span class="cov2" title="4">url := e.Options.EventAPIURL + "/v2/subscriptions"
        e.Logger.Debug("subscription URL", "url", url)
        req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                e.Logger.Error("failed to create request", "error", err)
                return err
        }</span>

        <span class="cov2" title="4">req.Header.Set("Authorization", "Bearer "+token)
        req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Accept", "application/json")

        resp, err := e.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                e.Logger.Error("failed to send request", "error", err)
                return err
        }</span>
        <span class="cov2" title="4">defer resp.Body.Close()

        if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                errData, _ := io.ReadAll(resp.Body)
                e.Logger.Error("failed to create subscription", "status_code", resp.StatusCode, "data", string(errData))
                return fmt.Errorf("failed to create subscription: %s", string(errData))
        }</span>

        <span class="cov2" title="4">var createdSubscription Subscription
        if err := json.NewDecoder(resp.Body).Decode(&amp;createdSubscription); err != nil </span><span class="cov0" title="0">{
                e.Logger.Error("failed to decode response", "error", err)
                return err
        }</span>
        <span class="cov2" title="4">e.Logger.Info("subscription created", "subscription_id", createdSubscription.ID)
        return nil</span>
}

// NewAggregateTypeSubscription creates a subscription for all messages of a specific aggregate type
func (e *EventClientImpl) NewAggregateTypeSubscription(ctx context.Context, topic string, aggregateType string, isRegex bool) error <span class="cov1" title="1">{
        return e.NewSubscriptionWithOptions(ctx, topic, aggregateType, nil, isRegex)
}</span>

// NewAggregateSubscription creates a subscription for a specific aggregate type and ID
func (e *EventClientImpl) NewAggregateSubscription(ctx context.Context, topic string, aggregateType string, aggregateID int, isRegex bool) error <span class="cov1" title="1">{
        return e.NewSubscriptionWithOptions(ctx, topic, aggregateType, &amp;aggregateID, isRegex)
}</span>

// GetOAuthToken is a public convenience function for obtaining OAuth tokens
func GetOAuthToken(ctx context.Context, oauthURL, clientID, clientSecret string) (string, error) <span class="cov0" title="0">{
        requestBody := map[string]string{
                "client_id":     clientID,
                "client_secret": clientSecret,
                "grant_type":    "client_credentials",
                "request_type":  "api",
        }

        jsonData, err := json.Marshal(requestBody)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal request body: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, http.MethodPost, oauthURL, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Accept", "application/json")

        client := &amp;http.Client{}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return "", fmt.Errorf("failed to get token: status %d, body: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var tokenResponse struct {
                AccessToken string `json:"access_token"`
                TokenType   string `json:"token_type"`
                ExpiresIn   int    `json:"expires_in"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;tokenResponse); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode token response: %w", err)
        }</span>

        <span class="cov0" title="0">return tokenResponse.AccessToken, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "fmt"
        "log/slog"
        "os"
        "time"

        "github.com/ambientlabscomputing/go_event_client"
)

func main() <span class="cov0" title="0">{
        // Create a logger
        logger := slog.New(slog.NewTextHandler(os.Stdout, &amp;slog.HandlerOptions{Level: slog.LevelDebug}))

        // Define options for the EventClient
        options := go_event_client.EventClientOptions{
                EventAPIURL:  "http://events.ambientlabsdev.io",
                SocketsURL:   "wss://sockets.ambientlabsdev.io",
                PingInterval: 1,
        }

        // Define a token callback function - in a real application,
        // you'd implement proper OAuth token fetching here
        getToken := func(ctx context.Context) (string, error) </span><span class="cov0" title="0">{
                // This example shows how you could use the test helper for development
                // In production, replace this with your own OAuth implementation
                config, err := go_event_client.LoadTestConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">return go_event_client.GetTestToken(ctx, config)</span>
        }

        // Create a new EventClient
        <span class="cov0" title="0">client := go_event_client.NewEventClient(context.Background(), options, getToken, logger)

        // Add handlers for different types of events

        // Handler for exact topic matching
        err := client.AddHandler("^example-1\\.topic$", func(message string) </span><span class="cov0" title="0">{
                fmt.Printf("Received message on exact match 'example-1.topic': %s\n", message)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to add exact match handler", "error", err)
                return
        }</span>

        // Handler for regex pattern matching
        <span class="cov0" title="0">err = client.AddHandler("^user\\..*$", func(message string) </span><span class="cov0" title="0">{
                fmt.Printf("Received user event: %s\n", message)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to add regex handler", "error", err)
                return
        }</span>

        // Handler for node events
        <span class="cov0" title="0">err = client.AddHandler("^node\\..*$", func(message string) </span><span class="cov0" title="0">{
                fmt.Printf("Received node event: %s\n", message)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to add node handler", "error", err)
                return
        }</span>

        // Start the client
        <span class="cov0" title="0">if err := client.Start(); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to start client", "error", err)
                return
        }</span>
        <span class="cov0" title="0">defer client.Stop()

        // Example 1: Basic subscription with exact matching
        err = client.NewSubscription(context.Background(), "example-1.topic")
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create basic subscription", "error", err)
                return
        }</span>

        // Example 2: Subscription with regex pattern matching
        <span class="cov0" title="0">err = client.NewSubscriptionWithOptions(context.Background(), "user\\..*", "", nil, true)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create regex subscription", "error", err)
                return
        }</span>

        // Example 3: Aggregate type subscription (all events for 'node' type)
        <span class="cov0" title="0">err = client.NewAggregateTypeSubscription(context.Background(), "node.events", "node", false)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create aggregate type subscription", "error", err)
                return
        }</span>

        // Example 4: Specific aggregate subscription (events for node ID 123)
        <span class="cov0" title="0">err = client.NewAggregateSubscription(context.Background(), "node.specific", "node", 123, false)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create specific aggregate subscription", "error", err)
                return
        }</span>

        // Give subscriptions time to be established
        <span class="cov0" title="0">fmt.Println("Subscriptions created. Waiting for them to be established...")
        time.Sleep(3 * time.Second)

        // Publish test messages to demonstrate different subscription types

        // Test basic subscription
        err = client.Publish("example-1.topic", map[string]string{
                "message": "Hello from basic subscription",
                "type":    "basic",
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to publish basic message", "error", err)
        }</span>

        // Test regex subscription
        <span class="cov0" title="0">err = client.Publish("user.created", map[string]interface{}{
                "message": "User created event",
                "user_id": 456,
                "type":    "user_event",
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to publish user message", "error", err)
        }</span>

        // Test aggregate type subscription
        <span class="cov0" title="0">err = client.Publish("node.events", map[string]interface{}{
                "message":    "Node event for all nodes",
                "event_type": "status_update",
                "type":       "aggregate_type",
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to publish aggregate type message", "error", err)
        }</span>

        // Test specific aggregate subscription
        <span class="cov0" title="0">err = client.Publish("node.specific", map[string]interface{}{
                "message": "Specific node event",
                "node_id": 123,
                "action":  "updated",
                "type":    "specific_aggregate",
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to publish specific aggregate message", "error", err)
        }</span>

        // Keep the client running for a while to receive messages
        <span class="cov0" title="0">fmt.Println("Client is running. Press Ctrl+C to exit.")
        fmt.Println("Waiting for messages...")
        time.Sleep(10 * time.Second)

        fmt.Println("Demo completed!")</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package go_event_client

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "log/slog"
        "net/http"
        "os"
        "strings"
        "time"

        "github.com/joho/godotenv"
)

// TestConfig holds configuration for tests
type TestConfig struct {
        OAuthClientID     string
        OAuthClientSecret string
        OAuthTokenURL     string
        EventAPIURL       string
        SocketsURL        string
        TestTimeout       time.Duration
        LogLevel          slog.Level
}

// LoadTestConfig loads test configuration from environment variables
func LoadTestConfig() (*TestConfig, error) <span class="cov5" title="5">{
        // Try to load .env file (ignore error if it doesn't exist)
        _ = godotenv.Load()

        config := &amp;TestConfig{
                OAuthClientID:     getEnvOrDefault("OAUTH_CLIENT_ID", "api_tester"),
                OAuthClientSecret: getEnvOrDefault("OAUTH_CLIENT_SECRET", "tester_scrt"),
                OAuthTokenURL:     getEnvOrDefault("OAUTH_TOKEN_URL", "http://api.ambientlabsdev.io/oauth/token"),
                EventAPIURL:       getEnvOrDefault("EVENT_API_URL", "http://events.ambientlabsdev.io"),
                SocketsURL:        getEnvOrDefault("SOCKETS_URL", "wss://sockets.ambientlabsdev.io"),
                TestTimeout:       30 * time.Second,
                LogLevel:          slog.LevelDebug,
        }

        // Parse timeout if provided
        if timeoutStr := os.Getenv("TEST_TIMEOUT"); timeoutStr != "" </span><span class="cov5" title="5">{
                if timeout, err := time.ParseDuration(timeoutStr); err == nil </span><span class="cov5" title="5">{
                        config.TestTimeout = timeout
                }</span>
        }

        // Parse log level if provided
        <span class="cov5" title="5">if logLevelStr := os.Getenv("LOG_LEVEL"); logLevelStr != "" </span><span class="cov5" title="5">{
                switch strings.ToLower(logLevelStr) </span>{
                case "debug":<span class="cov5" title="5">
                        config.LogLevel = slog.LevelDebug</span>
                case "info":<span class="cov0" title="0">
                        config.LogLevel = slog.LevelInfo</span>
                case "warn":<span class="cov0" title="0">
                        config.LogLevel = slog.LevelWarn</span>
                case "error":<span class="cov0" title="0">
                        config.LogLevel = slog.LevelError</span>
                }
        }

        <span class="cov5" title="5">return config, nil</span>
}

func getEnvOrDefault(key, defaultValue string) string <span class="cov10" title="25">{
        if value := os.Getenv(key); value != "" </span><span class="cov10" title="25">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

// OAuthToken represents an OAuth token response
type OAuthToken struct {
        AccessToken string `json:"access_token"`
        TokenType   string `json:"token_type"`
        ExpiresIn   int    `json:"expires_in"`
}

// GetTestToken fetches an OAuth token for testing
func GetTestToken(ctx context.Context, config *TestConfig) (string, error) <span class="cov8" title="14">{
        data := map[string]string{
                "grant_type":    "client_credentials",
                "client_id":     config.OAuthClientID,
                "client_secret": config.OAuthClientSecret,
                "request_type":  "api",
        }

        jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal request data: %w", err)
        }</span>

        <span class="cov8" title="14">req, err := http.NewRequestWithContext(ctx, "POST", config.OAuthTokenURL, strings.NewReader(string(jsonData)))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov8" title="14">req.Header.Add("Content-Type", "application/json")

        client := &amp;http.Client{Timeout: 10 * time.Second}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov8" title="14">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return "", fmt.Errorf("unexpected status code: %d, body: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov8" title="14">var tokenResp OAuthToken
        if err := json.NewDecoder(resp.Body).Decode(&amp;tokenResp); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode token response: %w", err)
        }</span>

        <span class="cov8" title="14">return tokenResp.AccessToken, nil</span>
}

// CreateTestLogger creates a logger for testing
func CreateTestLogger(level slog.Level) *slog.Logger <span class="cov4" title="4">{
        opts := &amp;slog.HandlerOptions{
                Level: level,
        }
        return slog.New(slog.NewTextHandler(os.Stdout, opts))
}</span>

// CreateTestClient creates a test client with proper configuration
func CreateTestClient(ctx context.Context, config *TestConfig) (EventClient, error) <span class="cov4" title="4">{
        logger := CreateTestLogger(config.LogLevel)

        options := EventClientOptions{
                EventAPIURL:  config.EventAPIURL,
                SocketsURL:   config.SocketsURL,
                PingInterval: 1,
        }

        getToken := func(ctx context.Context) (string, error) </span><span class="cov7" title="12">{
                return GetTestToken(ctx, config)
        }</span>

        <span class="cov4" title="4">return NewEventClient(ctx, options, getToken, logger), nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
